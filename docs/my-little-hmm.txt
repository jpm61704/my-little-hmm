-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/my-little-hmm#readme</a>
@package my-little-hmm
@version 0.1.0.0

module HMM
type Probability = CReal

-- | The definition of a hidden markov model s := data type of states o :=
--   data type of observations p := data type of probabilities t := a
--   traversable functor to contain the states and observations
data HMM s o p t
HMM :: t s -> t o -> s -> p -> s -> s -> p -> s -> o -> p -> HMM s o p t
[states] :: HMM s o p t -> t s
[observations] :: HMM s o p t -> t o
[initialProbability] :: HMM s o p t -> s -> p
[stateTransitions] :: HMM s o p t -> s -> s -> p
[observationProbability] :: HMM s o p t -> s -> o -> p
stateCount :: (Traversable t) => HMM s o p t -> Int
observationCount :: (Traversable t) => HMM s o p t -> Int
data StateInfo s o p
StateInfo :: p -> s -> p -> s -> p -> o -> p -> StateInfo s o p
[pi_s] :: StateInfo s o p -> p
[p_inbound] :: StateInfo s o p -> s -> p
[p_outbound] :: StateInfo s o p -> s -> p
[p_obs] :: StateInfo s o p -> o -> p
stateInfo :: HMM s o p t -> s -> StateInfo s o p
overStateSpace :: (Foldable t, Ord s) => HMM s o p t -> (s -> a) -> Map s a
data ObservationSeq o seq
ObsSeq :: o -> seq o -> ObservationSeq o seq
[first] :: ObservationSeq o seq -> o
[rest] :: ObservationSeq o seq -> seq o
fromList :: [o] -> ObservationSeq o []
data StateSeq o seq
StateSeq :: (seq o) -> StateSeq o seq

-- | a function applied to the probabilities of transition(a_ij * alpha_i)
--   from s_i to s_j
pIntoG :: (Num p) => (p -> p -> p) -> StateInfo s o p -> Map s p -> p
accumMultiply :: (Num p) => (p -> p -> p) -> StateInfo s o p -> s -> p -> p -> p

module ForwardAlgorithm

-- | the probability of an observation sequence occurring given a model
--   
--   this is problem 1, or the likelihood problem, in most HMM texts
likelihood :: (Traversable t, Functor t, Num p, Foldable seq, Ord s) => HMM s o p t -> ObservationSeq o seq -> p
type Alpha p = p
type AlphaMap s p = Map s p

-- | The alpha calculation made for an entire observation sequence This is
--   summed over to achieve the probability of a sequence occurring
alphas_T :: (Traversable t, Functor t, Num p, Foldable seq, Ord s) => HMM s o p t -> ObservationSeq o seq -> AlphaMap s p

-- | the alphas for observation o_t with respect to the alphas from the
--   previous observation.
alphas_t :: (Num p, Ord s, Foldable t) => AlphaMap s p -> HMM s o p t -> o -> AlphaMap s p

-- | The alphas for observation o_1 given a model
alphas_1 :: (Num p, Ord s, Foldable t) => HMM s o p t -> o -> AlphaMap s p

-- | the abstract calculation for the alphas of an observation o with
--   respect to a model and observation. The first argument is a function
--   that calculates the alpha value for a given state s_i given its
--   StateInfo view and the observation. \ This is used to provide an
--   abstraction so that addition data can be curried into the function
--   before alpha's is called.
alphas' :: (Num p, Ord s, Foldable t) => (StateInfo s o p -> o -> Alpha p) -> HMM s o p t -> o -> AlphaMap s p

-- | the calculation of a forward variable with respect to the first
--   observation in a sequence
alpha1 :: (Num p) => StateInfo s o p -> o -> Alpha p

-- | the calculation for a forward variable for any (non-initial)
--   observation with respect to the previous observation's forward
--   variables, the current state's(s_j) state info
alpha_t :: (Num p) => AlphaMap s p -> StateInfo s o p -> o -> Alpha p

-- | The probability of transitioning into state s_j from all other states
--   given the forward variable from the previous observation
pInto :: (Num p) => StateInfo s o p -> AlphaMap s p -> p

module Example
data Weather
Start :: Weather
Hot :: Weather
Cold :: Weather
data IceCreams
One :: IceCreams
Two :: IceCreams
Three :: IceCreams
obs_prob :: Weather -> IceCreams -> Probability
trans_prob :: Weather -> Weather -> Probability
exampleHMM :: HMM Weather IceCreams Probability []
trial1 :: [IceCreams]
trial2 :: [IceCreams]
t_1 :: ObservationSeq IceCreams []
t_2 :: ObservationSeq IceCreams []
instance GHC.Classes.Ord Example.IceCreams
instance GHC.Show.Show Example.IceCreams
instance GHC.Classes.Eq Example.IceCreams
instance GHC.Classes.Ord Example.Weather
instance GHC.Show.Show Example.Weather
instance GHC.Classes.Eq Example.Weather

module Lib
someFunc :: IO ()

module Viterbi
decode :: (Traversable t, Functor t, Num p, Ord p, Foldable seq, Ord s) => HMM s o p t -> ObservationSeq o seq -> V s p

-- | The viterbi variable aggregate which includes the probability and
--   (most likely) previous state for backtracing
data V s p
V :: s -> p -> V s p
Vi :: p -> V s p
vNil :: (Num p) => V s p
probv :: V s p -> p
probV :: () => V s p -> p
type ViterbiMap s p = Map s (V s p)
viterbis_T :: (Foldable seq, Num p, Ord p, Foldable t, Ord s) => HMM s o p t -> ObservationSeq o seq -> ViterbiMap s p

-- | viterbi variable for the first observation(O_1) in a sequence
viterbis_1 :: (Num p, Ord s, Foldable t) => HMM s o p t -> o -> ViterbiMap s p
viterbis_t :: (Num p, Ord p, Foldable t, Ord s) => ViterbiMap s p -> HMM s o p t -> o -> ViterbiMap s p
viterbi_t :: (Num p, Ord p) => ViterbiMap s p -> StateInfo s o p -> o -> V s p

-- | calculations the maximal value and its argument when a function f is
--   applied to a foldable functor
argmax :: (Ord a, Foldable t, Functor t) => (b -> a) -> t b -> (a, b)
pIntoV :: (Num p, Ord p) => StateInfo s o p -> Map s (V s p) -> (V s p)
instance (GHC.Classes.Ord s, GHC.Classes.Ord p) => GHC.Classes.Ord (Viterbi.V s p)
instance (GHC.Classes.Eq s, GHC.Classes.Eq p) => GHC.Classes.Eq (Viterbi.V s p)
instance (GHC.Show.Show s, GHC.Show.Show p) => GHC.Show.Show (Viterbi.V s p)
instance GHC.Base.Functor (Viterbi.V s)
